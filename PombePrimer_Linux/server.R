#To update vData, vectorData or the tabPanel 'Vector sequences', use the script in /data/Rscript_updateVectorSequences.R


#### PROCESSING OF LIST OF SYSTEMATIC ID'S (genelist)#####

##Flanking-region getter function

    #for N-terminal insertions
    fun.subseq.pos.Nter <- function(a,b,c,strand, maxsize) {
      #a is the chromosome number
      #b is the CDS start coordinate
      #c is the CDS end coordinate
      #strand is the chromosome strand
      #maxsize is the size of the extracted sequence, which is dependent one the flanking region size determined by the user
      
      if(strand==1) {
        RF <- toString(subseq(eval(parse(text=a)), start=b, width=maxsize))         #'RF' understood as the right flanking region starting from the ATG
        LF <- toString(subseq(eval(parse(text=a)), start=b-maxsize, width=maxsize))      #'LF' understood as the left flanking region starting just before the ATG
      } else if(strand==-1) {
        RF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=c+1-maxsize, width=maxsize)))         #'RF' understood as the right flanking region starting from the ATG
        LF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=c+1, width=maxsize)))      #'LF' understdood as the left flanking region starting just before the ATG
        
      } else stop('no strand assigned??')
      return(cbind(LF, RF))
    }
    
    #for C-terminal insertions
    fun.subseq.pos.Cter <- function(a,b,c,strand,maxsize) {
      #maxsize is the size of the extracted sequence, which is dependent one the flanking region size determined by the user. Generated by val.sizeampliconR(), see in shyniServer
      
      if(strand==1) {
        RF <- toString(subseq(eval(parse(text=a)), start=c-2, width=maxsize))         #'RF' understood as the right flanking region starting just before the STOP codon
        LF <- toString(subseq(eval(parse(text=a)), start=c-2-maxsize, width=maxsize))      #'LF' understood as the left flanking region starting from the STOP codon
      } else if(strand==-1) {
        RF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=b+3-maxsize, width=maxsize)))         #'RF' understood as the right flanking region starting from the ATG
        LF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=b+3, width=maxsize)))      #'LF' understdood as the left flanking region starting just before the ATG
        
      } else stop('no strand assigned??')
      return(cbind(LF, RF))
    }
    
    #for custom insertions. This function is converted to reactive with the name 'fun.subseq.pos.customR'
    fun.subseq.pos.custom <- function(coord, coordR3=NULL, maxsize, custom) {
    #coord is list(a, b, strand)
    #coordR3 is list(a, c, strand) when a 3' coordinate for deletion is supplied
    #a is the chromosome
    #b is the custom (5') coordinate
    #c is the 3' coordinate
    #strand is the gene strand
    #maxsize is the size of the extracted sequence, which is dependent one the flanking region size determined by the user
    #custom is a switch to select either 'custom insertion' or 'custom deletion'
    #note that a and c are assumed to be equal for deletions, because this is pre-checked in validate statements
    a <- coord[[1]]
    b <- coord[[2]]
    strand <- coord[[3]]
    stretch <- NULL
    
    if(custom == 'insertion') {
        if(strand==1) {
          RF <- toString(subseq(eval(parse(text=a)), start=b, width=maxsize))         #'RF' understood as the right flanking region starting from the ATG
          LF <- toString(subseq(eval(parse(text=a)), start=b-maxsize, width=maxsize))      #'LF' understood as the left flanking region starting just before the ATG
        }
        if(strand==-1) {
          RF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=b+1-maxsize, width=maxsize)))         #'RF' understood as the right flanking region starting from the ATG
          LF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=b+1, width=maxsize)))      #'LF' understdood as the left flanking region starting just before the ATG
        }
    }
    
    if(custom == 'deletion') {
      c <- coordR3[[2]]
      
      #This 'stretch' is the nt between the two coordinates for deletion, which has to be added to the amplicon size of ch_primers
      stretch <- abs(c - b)
      #note: delention works as [coordinate-coordinate], i.e, everything including the coordinates is deleted
      #'and the result is LF=..5'coordinate-1, RF=3'coordinate+1 
      if(strand==1) {
        RF <- toString(subseq(eval(parse(text=a)), start=c+1, width=maxsize))         #'RF' understood as the right flanking region starting just after the custom 3' coordinate
        LF <- toString(subseq(eval(parse(text=a)), start=b-maxsize, width=maxsize))      #'LF' understood as the left flanking region starting just before the custom 5' coordinate
      }
      if(strand==-1) {
        RF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=c-maxsize, width=maxsize)))         #'RF' understood as the right flanking region starting from the custom 3' coordinate
        LF <- toString(reverseComplement(subseq(eval(parse(text=a)), start=b+1, width=maxsize)))      #'LF' understdood as the left flanking region starting just before the custom 5' coordinate
      }
    }
    
    result <- data.frame(nameID=paste(coord, collapse=':'), LF=LF, RF=RF, stringsAsFactors = F)
    return(list(result, stretch))
  }  
    

#This function reads the input$systematicID or the input$coordinates, and returns a vector of elements
func.readlist <- function(a) {
  a <- gsub("^\\s+|\\s+$", "", a)                 #trim leading and trailing whitespaces
  if(grepl(",", a) == T) {
    a <- unlist(strsplit(a, split=' *, *,*'))     #detect and split by commas and possible spaces, including commas with no ID in between
  } else if(grepl("\\s", a) == T) {
    a <- unlist(strsplit(a, split= '\\s+')) #detect and split by spaces or tabs
    }
  return(a)
}

#This function takes gene.list, maps common name and adds chromosomal flanking regions to design primrs on
fun.updateGeneList <- function(gene.list, subseqfunction, maxsize) {
  #gene.list is the processed (mapped to chromosomal coordinates) genelist
  #subseqfunction is either of fun.subseq.pos.Nter, .Cter or .custom functions, used to extract the flanking regions from the genome
  #maxsize is the size of the extracted sequence, which is dependent one the flanking region size determined by the user, given by val.sizeampliconR()
  maxsize <- maxsize[[2]]
  gene.list <- merge(gene.list, namemap[,c('ID','nameID')], by='ID', all.x=T, sort=F) #get the common names for the genes, to present in the results table
  gene.list <- data.frame(gene.list,
                          do.call(rbind,
                                  mapply(subseqfunction,
                                         as.character(gene.list$chromosome), gene.list$start, gene.list$end, gene.list$strand, maxsize, SIMPLIFY=F)                #note that since gene.list$chromosome is a vector, it has to be converted to character to be correctly interpreted
                          ),
                          stringsAsFactors=F)
  colnames(gene.list)[1] <- 'SystematicID'
  return(gene.list)
}



#### PRIMER DESIGN WITH Primer3####

#basic primer3 configuration
  #set a platform-independent file path
fpath <- file.path('ResourcesAndDownloads', 'primer3-2.3.7', 'src')

#Primer3 caller funtion
func.primer3 <- function(a) {
  #a = p3.input
  try(system2(sprintf(file.path(fpath, 'primer3_core')), a, stdout=T))
}

pconfig <- c(
  "PRIMER_TASK=generic",
  "PRIMER_MIN_TM=55",
  "PRIMER_OPT_TM=60",
  "PRIMER_MAX_TM=62",
  "PRIMER_NUM_RETURN=2",
  "PRIMER_TM_FORMULA=1",
  "PRIMER_SALT_CORRECTIONS=1",
  "PRIMER_PICK_LEFT_PRIMER=1",
  "PRIMER_PICK_RIGHT_PRIMER=1",
  "PRIMER_OPT_SIZE=20",
  "PRIMER_MIN_SIZE=18",
  "PRIMER_MAX_SIZE=27",
  "PRIMER_EXPLAIN_FLAG=1",
  "PRIMER_PAIR_MAX_DIFF_TM=25",
  "PRIMER_WT_HAIRPIN_TH=6",
  sprintf("PRIMER_THERMODYNAMIC_PARAMETERS_PATH=%s", file.path(fpath, "primer3_config", "")),
  "=")
#NOTE the '' at the end of file.path, to add a '/' (in linux, or the correspondent system separator), so 'primer3_config' becomes directory ('primer3_config/')

  

#This function processes the results of the primer3 call
func.processprimers <- function(out, prefix, name) {    #prefix 'ch_' or 'HR_'
  returned.primers <- as.numeric(out[out[,1]=='PRIMER_PAIR_NUM_RETURNED',2])

  if (returned.primers>0){
    designed.primers <- do.call(cbind, lapply(0:1, function(i) {
      left.primer <- c(paste0(prefix, name, '-F'), 
                       out[out[,1]==paste0('PRIMER_LEFT_', i, '_SEQUENCE'),2],
                       out[out[,1]==paste0('PRIMER_LEFT_', i, '_TM'), 2],
                       ifelse(length(out[out[,1]==paste0('PRIMER_LEFT_', i, '_PROBLEMS'),2])==0, 'none', out[out[,1]==paste0('PRIMER_LEFT_', i, '_PROBLEMS'),2]),
                       strsplit(out[out[,1]==paste0('PRIMER_LEFT_', i), 2], ',')[[1]][1],            #this is the position of the primer, in <5'pos>,<3'pos> (start,end)
                       "")
      right.primer <- c(paste0(prefix, name, '-R'),
                       out[out[,1]==paste0('PRIMER_RIGHT_', i, '_SEQUENCE'),2],
                       out[out[,1]==paste0('PRIMER_RIGHT_', i, '_TM'), 2],
                       ifelse(length(out[out[,1]==paste0('PRIMER_RIGHT_', i, '_PROBLEMS'),2])==0, 'none', out[out[,1]==paste0('PRIMER_RIGHT_', i, '_PROBLEMS'),2]),
                       strsplit(out[out[,1]==paste0('PRIMER_RIGHT_', i), 2], ',')[[1]][1],
                       out[out[,1]==paste0('PRIMER_PAIR_', i, '_PRODUCT_SIZE'),2])
      
      if(returned.primers==99) { #func.primer_vector.chV will return a PRIMER_PAIR_NUM_RETURNED=99, since it gives no primer pairs
        right.primer[6] <- ''
        des.primers <- data.frame(Gene = name, rbind(left.primer, right.primer))} else {
        des.primers <- data.frame(Gene = name, rbind(left.primer, right.primer))
        }
      colnames(des.primers) = paste0(c('Gene', 'label', 'sequence', 'Tm', 'problems', 'startPosition', 'product size'), '_', i)
      
      return(des.primers)
      
      }))  
  }
}


##Primer designer Sub-functions

#To design 'checking primers' (a primer pair that flanks the target region and can be used to check for correct cloning and genomic insertion)
func.primer_ch <- function(name, sequence, maxsize) {
  #maxsize is the size of the extracted sequence, which is dependent one the flanking region size determined by the user. Generated by val.sizeampliconR(), see in shyniServer
  p3.input=tempfile()     #this is the primer 3 input file, that must be present in the directory. Creating is as a temp file saves cluttering
  seqtarget <- paste(maxsize-15, 30, sep=',')
  write(append(c(
    sprintf("SEQUENCE_ID=%s",name),
    sprintf("SEQUENCE_TEMPLATE=%s",as.character(sequence)),
    sprintf("SEQUENCE_TARGET=%s", seqtarget),            #the region is defined by start,width. In effect, this means that the target is at position 900 (maxsize), i.e. the junction between the flanking regions
    "PRIMER_PRODUCT_SIZE_RANGE=250-600 100-250",
    "PRIMER_PAIR_WT_DIFF_TM=0.3",
    "PRIMER_PICK_ANYWAY=1"
    ),
  pconfig),
  p3.input)
  
  out <- as.data.frame(do.call(rbind, strsplit(func.primer3(p3.input), split="=")), stringsAsFactors=F)
  unlink(p3.input) # delete temp files
  designed.primers <- func.processprimers(out, 'ch_', name)
  return(designed.primers)
}

#To design 'Homologus Recombination (HR)' primers. The ..-LF designs a primer pair immediately 5' to the target
func.primer_HRLF <- function(name, sequence, sizeamplicon, maxsize) {
  #maxsize is the size of the extracted sequence, which is dependent one the flanking region size determined by the user. Generated by val.sizeampliconR(), see in shyniServer
  
  p3.input=tempfile()     #this is the primer 3 input file, that must be present in the directory. Creating is as a temp file saves cluttering
  write(append(c(
    sprintf("SEQUENCE_ID=%s",name),
    sprintf("SEQUENCE_TEMPLATE=%s",as.character(sequence)),
    sprintf("SEQUENCE_FORCE_RIGHT_START=%s", maxsize-1),    ##Note the 0-indexing for the start base! It forces the 5' end, use with the LF on base nchar(seq)=900            
    "PRIMER_PICK_ANYWAY=1",
    sprintf("PRIMER_PRODUCT_SIZE_RANGE=%s", as.character(sizeamplicon)) #,"PRIMER_PRODUCT_SIZE_RANGE=600-900"
       ),
    pconfig),
    p3.input)
  
  out <- as.data.frame(do.call(rbind, strsplit(func.primer3(p3.input), split="=")), stringsAsFactors=F)
  unlink(p3.input) # delete temp files
  designed.primers <- func.processprimers(out, 'HR_LF_', name)
  return(designed.primers)
}

#The ..-RF designs a primer pair on the target and its 3' sequence
func.primer_HRRF<- function(name, sequence, sizeamplicon) {
  
  p3.input=tempfile()     #this is the primer 3 input file, that must be present in the directory. Creating is as a temp file saves cluttering
  write(append(c(
    sprintf("SEQUENCE_ID=%s",name),
    sprintf("SEQUENCE_TEMPLATE=%s",as.character(sequence)),
    "SEQUENCE_FORCE_LEFT_START=0",    #Note the 0-indexing for the start base! This parameter forces the 5' end, use with the LF on base nchar(seq)=900    
    "PRIMER_PICK_ANYWAY=1",
    sprintf("PRIMER_PRODUCT_SIZE_RANGE=%s", as.character(sizeamplicon)) #,"PRIMER_PRODUCT_SIZE_RANGE=600-900"
       ),
    pconfig),
    p3.input)
  
  out <- as.data.frame(do.call(rbind, strsplit(func.primer3(p3.input), split="=")), stringsAsFactors=F)
  unlink(p3.input) # delete temp files
  designed.primers <- func.processprimers(out, 'HR_RF_', name)
  return(designed.primers)
}

#To desing the vector cloning primers for the custom-input backbone and insert
func.primer_vector.clo <- function(seq1, primertag) {
  #primertag is the initial of the primer name, i.e. 'back' or 'ins' for the backbone or the insert.
  p3.input=tempfile()     #this is the primer 3 input file, that must be present in the directory. Creating is as a temp file saves cluttering
  write(append(c(
    "PRIMER_TASK=pick_cloning_primers",
    sprintf("SEQUENCE_TEMPLATE=%s",as.character(seq1)),
    "PRIMER_PICK_ANYWAY=1"
    ),
  pconfig[-1]), #this replaces the line "PRIMER_TASK=generic" in pconfig by the line "PRIMER_TASK=pick_cloning_primers" supplied above
  p3.input)
  
  out <- as.data.frame(do.call(rbind, strsplit(func.primer3(p3.input), split="=")), stringsAsFactors=F)
  unlink(p3.input) # delete temp files
  designed.primers <- func.processprimers(out, primertag, '')
  designed.primers[,1] <- 'avector'
  return(designed.primers)
}

#To design the vector checking primers (chV_) for the custom-input insert
func.primer_vector.chV <- function(seq1) {
  #pick right (reverse) primer in the first 300 nt of the sequence
  p3.input=tempfile()     #this is the primer 3 input file, that must be present in the directory. Creating is as a temp file saves cluttering
  seqtarget <- c('50,300')
  write(append(c(
    sprintf("SEQUENCE_TEMPLATE=%s",as.character(seq1)),
    sprintf("SEQUENCE_INCLUDED_REGION=%s", seqtarget),
    "PRIMER_PICK_LEFT_PRIMER=0"
  ),
  pconfig[c(-8, -14)]), #so it picks only the right primer
  p3.input)
  
  out.right <- as.data.frame(do.call(rbind, strsplit(func.primer3(p3.input), split="=")), stringsAsFactors=F)
  unlink(p3.input) # delete temp files
  
  #pick left (forward) primer in the last 300 nt of the sequence
  p3.input=tempfile()     #this is the primer 3 input file, that must be present in the directory. Creating is as a temp file saves cluttering
  seqtarget <- paste(nchar(seq1)-300, 299, sep=',')
  write(append(c(
    sprintf("SEQUENCE_TEMPLATE=%s",as.character(seq1)),
    sprintf("SEQUENCE_INCLUDED_REGION=%s", seqtarget),
    "PRIMER_PICK_RIGHT_PRIMER=0"
  ),
  pconfig[c(-9, -14)]), #so it picks only the left primer
  p3.input)
  
  out.left <- as.data.frame(do.call(rbind, strsplit(func.primer3(p3.input), split="=")), stringsAsFactors=F)
  unlink(p3.input) # delete temp files
  
  #this function generates right and left primers independently, so I need a PRIMER_PAIR_NUM_RETURNED as a workaround for the func.processprimers
  out <- rbind(out.right, out.left)
  out <- out[!out[,1]=='PRIMER_PAIR_NUM_RETURNED',]   #get rid of 'PAIR_RETURNED' data, to replace it below
  
  if(as.numeric(out[out[,1]=='PRIMER_RIGHT_NUM_RETURNED',2])[1]>0 &
     as.numeric(out[out[,1]=='PRIMER_LEFT_NUM_RETURNED',2])[2]>0
     ) out <- rbind(out, c('PRIMER_PAIR_NUM_RETURNED', 99)) else {warning('primers not detected for ', name, call. = FALSE); return(NA)}
    
  designed.primers <- func.processprimers(out, 'chV', '')
  designed.primers[,1] <- 'avector'
  cat('chV primers designed \n')
  return(designed.primers)
}


#### Main primer design functions####

#This function designs the ch_ primers in the full-sized flanking regions and updates Gene.list with the primer-trimmed flanking regions
fun.designPrimers <- function(genelist, maxsize, HRL, HRR, cusdeletion){
  #genelist refers to the systematicID provided
  #sizeamplicon is the reactive val.sizeampliconR(), taking values like '600-900'
  #maxsize is maximum the size of the extracted sequence, which is dependent one the flanking region size determined by the user. Generated by val.sizeampliconR(), see in shyniServer
  #HRL is the validated HR_LF.primers
  #HRR is the validated HR_RF.primers
     
  #if sizeOverlap==0, this means that no vectors or custom backbone/insert have been supplied, so I'm using this
     #'in an "if" statement to decided whether or not to create clo_ and chV_ primers, so func.designPrimers does not need to be reactive
  gene.list <- genelist
  maxsize <- maxsize[[2]]
  
  #Update flanking region sizes in gene.list using HR_ primer positions.
  productsize <- as.numeric(as.character(HRL$startPosition_0))
  productsize <- productsize[seq(1,length(productsize),2)] #This extracts the start position of the HR_LF-F primers
  gene.list$LF <- do.call(rbind, 
                          mapply(function(a, b) substr(a, b+1, maxsize),   #note that the start position is 0-base indexed, that's why I'm adding +1 to the count
                                 gene.list$LF,
                                 productsize,
                                 SIMPLIFY=F))
  
  productsize <- as.numeric(as.character(HRR$"product size_0"))
  productsize <- productsize[!is.na(productsize)]
  gene.list$RF <- do.call(rbind,
                          mapply(function(a,b) substr(a, 1, b),     
                                 gene.list$RF,
                                 productsize,
                                 SIMPLIFY=F))
 
   ##checking primers##
  gene.l <- data.frame(as.character(gene.list$nameID), paste0(gene.list$LF, gene.list$RF), stringsAsFactors=F) #this vector contains the full LF+RF to design checking primers around the ATG
  ampmaxsize <- lapply(gene.list$LF, nchar) #this is the max size of the left flanking region
  ch.primers <- mapply(func.primer_ch, name=gene.l[,1], sequence=gene.l[,2], ampmaxsize, SIMPLIFY=F)
  if(!any(unlist(lapply(ch.primers, is.null)))) {
      func.arrangechprimers <- function(a, ampmaxsize) {
        a <- a[,c(1:3,7,4:6)]
        a$startPosition_0 <- as.numeric(as.character(a$startPosition_0))
        #adjust start positions of the primers, so they refer to the target (this way the user can take this values and calculate amplicon sizes with custom opposite primers)
        a[1, 'startPosition_0'] <- -(ampmaxsize - a[1,'startPosition_0'])
        a[2, 'startPosition_0'] <- a[2,'startPosition_0'] - ampmaxsize
        a <- a[,-8]
        return(a)
      }
      ch.primers <- mapply(func.arrangechprimers, ch.primers, ampmaxsize, SIMPLIFY = F) #the parsing is finished below, after adding chV primer data
      
      #If custom deletion has been selected, add the size of the deleted region to the Amplicon size.
      if(cusdeletion ==4) {
      ch.primers <- mapply(function(a,b) {a[,4]<-as.numeric(as.character(a[,4])) + as.numeric(b); return(a)},
                          ch.primers, stretch[,2], SIMPLIFY=F)
      }
      
      cat("primers (list) to check correct insertion... designed\n")
  }
    
  return(list(HRL, HRR, ch.primers, gene.list))
  #if vector or custom backbone/insert are supplied (i.e. 'sizeOverlap != 0'), add clo_ and chV_ primers to the list,
    #'plus update the last column of the table to contain the amplicon size of ch-F/chV-R and ch-R/chV-F
  #Also distinguish between custom backbone/insert sequences, and those coming from the supplied dropdown list, using input from input$GibsonCustom
}


#This function designs backbone_, insert_ and chV_primers from the custom-input backbone and insert sequences
func.designprimersVector.C1 <- function(seqVector, vData.f, vectorData){
  #seqVector is a list with the sequences of the vector backbone and insert that comes from Gibsonmodules()[1:2], used in the functions func.primer_vector.clo and func.primer_vector.chV
  #vData.f is the choice in the plasmid dropdown list
  #vectorData is a list with vector and insert sequences, loaded from Global.R
  
    backbone.primers <- func.primer_vector.clo(seqVector[[1]], 'backbone')[,c(1:3,7,4:6)]
    backbone.primers$startPosition_0 <- NA  #anyway, note that due to 0-indexing the startpos is nchar-1
    
    insert.primers <- func.primer_vector.clo(seqVector[[2]], 'insert')[,c(1:3,7,4:6)]
    insert.primers$startPosition_0 <- NA
    
    chV.primers <- func.primer_vector.chV(seqVector[[2]])[c(1:3,7,4:6)]
    chV.primers[,"startPosition_0"] <- as.numeric(as.character(chV.primers[,"startPosition_0"]))
    chV.primers[1,7] <- -(nchar(seqVector[[2]]) - chV.primers[1,7])
    chV.primers[2,7] <- chV.primers[2,7] + 1 #to correct the 0-indexing
    return(list(backbone.primers, insert.primers, chV.primers))
}     

#This function designs backbone_, insert_ and chV_primers from the pre-made backbone and insert sequences vectorData list
func.designprimersVector.C0 <- function(seqVector, vData.f, vectorData){
  #seqVector is a list with the sequences of the vector backbone and insert that comes from Gibsonmodules()[1:2], used in the functions func.primer_vector.clo and func.primer_vector.chV
  #vData.f is the choice in the plasmid dropdown list
  #vectorData is a list with vector and insert sequences, loaded from Global.R
  
     if(vData.f != 'noInput'){
      vdat <- vectorData[[1]]
      backbone.primers <- vectorData[[1]][,c(1,3:9)]
      backbone.primers <- backbone.primers[backbone.primers[,1] == vData.f, -1]
      
      insert.primers <- vectorData[[1]][c(1,12:18)]
      insert.primers <- insert.primers[insert.primers[,1] == vData.f, -1]  #here insert.Tm is numeric, so when e.g. 60.0 is selected, the 0 dissapears. Maybe fix this format problem in the future?
      
      chV.primers <- vectorData[[2]]
      chV.primers <- chV.primers[chV.primers$Gene_0 == vData.f,]
      return(list(backbone.primers, insert.primers, chV.primers))
    }
    
  }



#This function adds the startPos of chV_primers to the ch_primers, to get band sizes
func.bandsize <- function(ch, chV)  {
  #ch, ch.primers
  #chV, chV.primers
  if(!is.null(ch)){
    ch[,7] <- c(paste0(as.character(ch[1,7]), ' (',as.character(abs(ch[1,7])+chV[2,7]), ')'),    #ch-F with chV-R, will look like e.g. -250 (500), representing StartPos for the ch.primer, just in case the user wants to use a custom chV primer, and bandsize if chV primers are used
                paste0(as.character(ch[2,7]), ' (',as.character(ch[2,7]+abs(chV[1,7])),')')     #ch-R with chV-F.
    )
  }
  return(ch)
}

#This function does the final parsing of the primers, putting them all together and adding band sizes
func.designprimersParse <- function(HR_LF.primers, HR_RF.primers,
                                    ch.primers, chV.primers,
                                    backbone.primers, insert.primers,
                                    sizeOverlap, genelist, overlapjunctions
                                    ){
  #overlapjunctions refers to the 5' tails added to the HR primers
  #sizeOverlap refers to the user-defined overlap length (recommended is 32 nt). I use it also as a switch in this function to tell whether there is a vector present or not
  
  #finish parsing the HR primers
  HR_LF.primers <- data.frame('Sequence'= as.character(paste0(overlapjunctions[1:2,2], as.character(HR_LF.primers[,3]))), HR_LF.primers[,c(1:7),])
  HR_RF.primers <- data.frame('Sequence'= as.character(paste0(overlapjunctions[3:4,2], as.character(HR_RF.primers[,3]))), HR_RF.primers[,c(1:7),])

  HR.primers <- rbind(HR_LF.primers, HR_RF.primers)
  HR.primers <- HR.primers[,c(2,3,1,8,5:7),]
  colnames(HR.primers) <- c('Gene', 'Primer', 'Sequence', 'Amplicon(bp)', 'Tm', 'problems', 'StartPos(BandSize)')
  HR.primers[,4] <- as.numeric(as.character(HR.primers[,4])) + c(0,sizeOverlap,0,sizeOverlap) #If overlaps (i.e. 5' tails) have been designed, this adds their length to the amplicon size
  HR.primers[,7] <- as.numeric(as.character(HR.primers[,7])) + 1 #to correct the 0-indexing
  HR.primers[,7] <- NA #this is irrelevant to the user
  rownames(HR.primers) <- NULL
  
  #finish parsing the ch.primers
  if(sizeOverlap!=0) { #if sizeOverlap==0, it means that there is no vector and therefore no vector primers to parse
    ch <- unlist(ch.primers)
    if(all(is.null(ch))) {
      lev <- levels(droplevels(HR.primers$Gene))
      ab <- matrix(nrow=length(lev), ncol=7)
      colnames(ab) <- colnames(HR.primers)
      ab[,1] <- lev
      ab[,2] <- 'ch_primers'
      ab[,3] <- 'could not design'
      ch.primers <- list(backbone.primers, insert.primers, chV.primers, ab)
    } else {
      ch.primers <- lapply(ch.primers, func.bandsize, chV.primers)
      ch.primers <- append(list(backbone.primers, insert.primers, chV.primers), ch.primers)
    }
    ch.primers <- lapply(ch.primers, function(a) return(as.matrix(setNames(a, NULL))))
  }
  
  ch.primers[unlist(lapply(ch.primers, is.null))] <- NULL #this eliminates the primers that could not be designed
 
  if(length(ch.primers)!=0) {
    ch.primers <- as.matrix(do.call(rbind, ch.primers))[,1:7] #If only one gene is selected and ch.primers cannot be designed, this prevents an error due to matrix(NULL)
    colnames(ch.primers) <- colnames(HR.primers)
  } else {
    lev <- levels(droplevels(HR.primers$Gene))
    ab <- matrix(nrow=length(lev), ncol=7)
    colnames(ab) <- colnames(HR.primers)
    ab[,1] <- lev
    ab[,2] <- 'ch_primers'
    ab[,3] <- 'could not design'
    ch.primers <- ab
  }
  
  HR.primers <- as.matrix(HR.primers)
  cat("primers to check correct homologous recombination... designed\n")
  
  All.primers <- rbind(HR.primers, ch.primers) 
  All.primers <- as.data.frame(All.primers, stringsAsFactors=F)
  All.primers <- All.primers[order(All.primers[,'Gene'], All.primers[, 'Primer']),] #All.primers[order(as.character(All.primers$Gene), All.primers$Primer),]
  All.primers$Tm <- strtrim(All.primers$Tm, 4)  #I know it's crude. Another option is set the 'digits' option of format.data.frame when the inital primer dataframes are made.
  rownames(All.primers) <- NULL
  return(list(All.primers, genelist))
}


#### NON-REACTIVE FUNCTIONS####

#mapping of ch.cds (coordinates) with namemap (systematicID-common name)
mappedgenelist <- merge(namemap[, c(1,4)], ch.cds, by=1)
colnames(mappedgenelist)[1] <- 'SystematicID'

#validation of coordinates respective to the size of the amplicons (flanking regions) and the chromosome width
val.vcoord <- function(a, chromosome, sizeamp) {
  a <- as.numeric(a)
  #a is the user-introduced coordinate
  #sizeamp is the val.sizeampliconR()
  leftend <- sizeamp[[2]] #5prime
  rightend <- width(chromosome) - sizeamp[[2]] #3prime
  validate(
    need(a <= rightend,
         paste0("You coordinate is too close to the 3' chromosome boundary (", rightend, " bp). You must set the maximum Flanking Region Size under ", rightend, " bp."))
  )
  validate(
    need(a > 99, 
         paste0("You coordinate is too close to the 5' chromosome boundary (", a, " bp). To clone the flanking region you should aim for 200 bp or longer"))
  )
  validate(
    need((a - leftend) > 0, 
         paste0("You coordinate is too close to the 5' chromosome boundary. You must set the maximum Flanking Region Size under ", a, " bp."))
  )
}

##for a custom coordinate, guess which gene the coordinate is closest to:
  #assign that closest match to either the gene or its 5' or 3'end
func.reducedmap <- function(coordinates) {
      #mappedgenelist is the merged files of common names with the coordinates
      #coordinates are the gene user-supplied coordinates
      #find the closest match
      #a is the mappedgenelist start or end of the gene
      #b is the user-defined coordinate
      
      #slice mappedgenelist to the chromosome and strand defined in the coordinates
      mappedgl <- mappedgenelist[mappedgenelist[, 'chromosome'] == coordinates[[1]] &
                             mappedgenelist[, 'strand'] == coordinates[[3]], ]
      func.mapcoord <- function(a,b) mappedgl[which(abs(a-b)==min(abs(a-b))),]
      prime5 <- func.mapcoord(mappedgl[,3], coordinates[[2]])
      rownames(prime5) <- NULL
      prime3 <- func.mapcoord(mappedgl[,4], coordinates[[2]])
      rownames(prime3) <- NULL
      
      if(prime5[,1] == prime3[,1]) prime5 else if(abs(prime5[3] - coordinates[[2]]) < abs(prime5[4] - coordinates[[2]])) prime5 else prime3
     
    }
  
#Func to create the overlaps between modules and flanking regions
func.Gibsonoverlaps <- function(module1, module2, gibs) {
    RFF <- tolower(toString(subseq(module1, end=length(module1), width=gibs))) #overlap of module1 3' end with 5' RF-F
    RFR <- tolower(toString(reverseComplement(subseq(module2, start=1, width=gibs)))) #overlap of RF-R with module2 5' end in reverse complement
    LFF <- tolower(toString(subseq(module2, end=length(module2), width=gibs))) #overlap of module2 3' end with 5' LF-F
    LFR <- tolower(toString(reverseComplement(subseq(module1, start=1, width=gibs)))) #overlap of LF-R with module1 5' end in reverse complement
    overlaps <- data.frame('region'= c('LF-F', 'LF-R', 'RF-F', 'RF-R'), 'sequence'=c(LFF, LFR, RFF, RFR))
    return(overlaps)
}

#This function is used in the func.customcoord
func.check <- function(lst,check) paste(lst[!check], collapse = ', ')

#This function validates custom coordinates (syntax and numbers), creates input for fun.subseq.pos.custom and
#guesses genes for the supplied coordinates
func.customcoord <- function(input, val.size) {
  # input is coord.list
  # val.size is val.sizeampliconR()
  check1 <- sapply(input, function(a) length(gregexpr(':', a, fixed=T)[[1]]) == 2)
  
  validate(need(all(check1), paste0('Coordinate ', func.check(input, check1), ' missing the ":" separator.'))
  )
  
  #Validate coordinate arrangement (chromosome:coordinate:strand)
  coordinates <- strsplit(input, split=':', fixed=T)
  coordinates <- lapply(coordinates, as.numeric)
  check2 <- sapply(coordinates, function(a) length(a) == 3)
  validate(need(all(check2), paste0('Bad coordinates: ', func.check(input, check2),
                '. You must add three coordinates separated by ":"'))
  )
  check3 <- sapply(coordinates, function(a) a[1] %in% 1:3)
  validate(need(all(check3), paste0('Bad coordinates: ', func.check(input, check3),
                '. Pombe has three chromosomes: 1, 2 or 3 must be input as the first coordinate'))
  )
  check4 <- sapply(coordinates, function(a) a[3] %in% c(1,-1))
  validate(need(all(check4), paste0('Bad coordinates: ', func.check(input, check4),
                '. A chromosome has two strands: 1 or -1 must be input as the third coordinate'))
  )
  
  #Validate coordinate data (distance to chromosome boundaries)
  func.vcd <- function(a) {
    #a is coordinates
  if(a[1]==1) val.vcoord(a[2], ch1, val.size)
  if(a[1]==2) val.vcoord(a[2], ch2, val.size)
  if(a[1]==3) val.vcoord(a[2], ch3, val.size)
  }
  lapply(coordinates, func.vcd)
  
  #Transform the coordinates input into arguments for the fun.subseq.pos.custom function
  coordinates <-lapply(coordinates, function(a) {a <- as.list(a); a[[1]] <- paste0('ch', a[[1]]); return(a)}) #to add the 'chromosome' to the number
  cat('Custom coordinates validated and systematicID guessed\n')
  cat('Flanking regions for custom coordinate added\n')
  return(coordinates)
}



shinyServer(function(input, output, session){
  
  
  ## Validation functions that use reactive input##
  
  #Validation of correct input overlap length 
  val.GibsonOverlapLength <- reactive({
    
    validate(need(input$overlapLength >=20, "Overlap is too short! \n You should use > 25 nt, and I recommend 32 nt of overlap")
    )
    if(input$GibsonCustom == 1) {
      if(input$Gmodule1 != "" | input$Gmodule2 != "") input$overlapLength else 0
    } else if(input$plasmidBackbones != 'noInput') input$overlapLength else 0
  })
  
  #validation of correct sizeamplicon
  val.sizeampliconR <- reactive({
    # It depends on input$FRlength
        
    Check.sizeamplicon <- input$FRlength
    
    validate(need(grepl("-", Check.sizeamplicon), "You need to supply two values separated by a dash, as in '600-900'")
    )
   
    Check.sizeamplicon.split <- as.numeric(unlist(strsplit(Check.sizeamplicon, split='-', fixed=T)))
    
    validate(need(length(Check.sizeamplicon.split)==2, "Flanking region size values must be two numbers, as in '600-900'")
    )
    validate(need(!is.na(Check.sizeamplicon.split[1]), "Flanking region size values must be numbers, as in '600-900'")
    )
    validate(need(!is.na(Check.sizeamplicon.split[2]), "Flanking region size values must be numbers, as in '600-900'")
    )
    validate(need(Check.sizeamplicon.split[1] <= Check.sizeamplicon.split[2], "The flanking region size min value must be equal or smaller than the max value")
    )
    validate(need(Check.sizeamplicon.split[1] > 50, "The minimun size of the flanking region must be bigger than 27 nt (the maximum primer size)")
    )
    
    list(Check.sizeamplicon, Check.sizeamplicon.split[2], Check.sizeamplicon.split[1])
   
  })

#Gibson modules validation function
val.Gibsmodules <- reactive({
  
  if(input$GibsonCustom == 1) {  
    validate(need(input$Gmodule1 != "", "No vector insert present"))
    m1 <- toupper(input$Gmodule1)
    validate(need(!grepl("[^ATCG]", m1), "Vector insert contains letters other than A T G C, please revise"))
    
    validate(need(input$Gmodule2 != "", "No vector backbone present"))
    m2 <- toupper(input$Gmodule2)
    validate(need(!grepl("[^ATCG]", m2), "Vector backbone contains letters other than A T G C, please revise"))
    
    validate(need(m1 != m2, "Both vector insert and backbone are identical, please revise"))
  }
  
})

 ## Reactive functions - processing ##

  
 #This function maps coordinates to gene.list and adds the flanking regions, to use as input to fun.designPrimers
  gene.list <- reactive({
    ##gene.list() depends on the input below, and is updated into upgene.list() with the trimmed flanking regions designed by fun.designPrimers()
    #- input$systematicID
    #- input$coord
    #- input$coordR5
    #- input$coordR3
    #- input$radio
    #- input$FRlength
    
    if(input$radio < 3) { #N-ter or C-ter
      validate(need(input$systematicID != "", "No systematic gene ID entered yet")
      )
      
      gene.list <- unique(toupper(func.readlist(input$systematicID)))
  
      gene.list2 <- ch.cds[toupper(ch.cds[,1]) %in% gene.list,]                                #map genome locations
      validate(need(
        length(gene.list) == length(gene.list2[,1]),
        paste("'",paste(gene.list[!gene.list %in% toupper(ch.cds[,1])], collapse=', '),"'", collapse=', ', "not Pombe systematic ID's"))
      )
      cat('systematicID validated\n')
      
      #map chromosome, strand and add flanking regions to gene.list2
      if(input$radio == 1) gene.list2 <- fun.updateGeneList(gene.list2, fun.subseq.pos.Nter, val.sizeampliconR()) else {
        if(input$radio == 2) gene.list2 <- fun.updateGeneList(gene.list2, fun.subseq.pos.Cter, val.sizeampliconR())}
      cat('Flanking regions added\n')

    }
    
    if(input$radio == 3) { #Custom insertion
      validate(need(input$coord != '', 'Please supply a Custom coordinate'))
     
      coord.list <- func.readlist(input$coord)
      coord.list <- func.customcoord(coord.list, val.sizeampliconR())
      gene.list2 <- lapply(coord.list, fun.subseq.pos.custom, maxsize=val.sizeampliconR()[[2]], custom = 'insertion')
      gene.list2 <- do.call(rbind, lapply(gene.list2, function(a) a[[1]])) #[[2]] is the 'stretch', i.e. the length of the deleted region if 'Custom deletion' is selected
      reducedmap <- do.call(rbind, lapply(coord.list, func.reducedmap))
      
      gene.list2 <- data.frame("SystematicID"=reducedmap[,1],
                               "nameID"=gene.list2[,1],
                               reducedmap[,c(3:length(reducedmap))],
                               gene.list2[,2:3],
                               stringsAsFactors = F)
    }
    
    if(input$radio == 4) { #Custom deletion
      validate(need(all(input$coordR5 != '', input$coordR3 != ''), 'Please supply Custom coordinates'))
    
      coord.listR5l <- func.readlist(input$coordR5)
      coord.listR3l <- func.readlist(input$coordR3)
      
      #validate that there are the same number of coordR5 than coordR3
      check.length <- length(coord.listR5l) == length(coord.listR3l)
      ifelse(length(coord.listR3l) > length(coord.listR5l), big <- "3' coordinates", big <- "5' coordinates")
      validate(need(check.length, paste0('The number of coordinates does not match, you have more ', big, '.')))
      
      coord.listR5 <- func.customcoord(coord.listR5l, val.sizeampliconR())
      coord.listR3 <- func.customcoord(coord.listR3l, val.sizeampliconR())
      #validate that the coordinate pairs are in the same chromosome
      check.chromosome <- unlist(lapply(coord.listR5, function(a) a[[1]])) == unlist(lapply(coord.listR3, function(a) a[[1]]))
      validate(need(all(check.chromosome),
                    paste("5'/ 3' coordinate pair not in the same chromosome: ",
                          coord.listR5l[!check.chromosome], ' / ', coord.listR3l[!check.chromosome])
               )
      )
      #validate that the coordinate pairs are in the same strand
        #check.cs is a numeric matrix of coordinate and strand
      check.cs <- cbind(
        do.call(rbind, lapply(coord.listR5, function(a) unlist(a[c(2,3)]) )),
        do.call(rbind, lapply(coord.listR3, function(a) unlist(a[c(2,3)]) ))
        )
      
      check.strand <- apply(check.cs, MARGIN=1, FUN=function(a) a[2] == a[4])
      validate(need(all(check.strand),
                    paste("5'/ 3' coordinate pair not in the same strand: ",
                          coord.listR5l[!check.strand], ' / ', coord.listR3l[!check.strand])
              )
      )
      
      #validate that the orientation of the coordinates is correct (i.e. 5' <= 3' for strand 1, and 5' >= 3' for strand -1)
      check.coordpos <- apply(check.cs,
                              MARGIN=1,
                              FUN=function(a) if(a[2] == 1) list(a[1] <= a[3], ". The 5' coordinate must be smaller than the 3' coordinate in the positive strand") else
                                                            list(a[1] >= a[3],  ". The 5' coordinate must be bigger than the 3' coordinate in the negative strand")
                              )
      check.coordpos.l <- unlist(lapply(check.coordpos, function(a) a[[1]]))
      check.coordpos.t <- unlist(lapply(check.coordpos, function(a) a[[2]]))
        
      validate(need(all(check.coordpos.l),
                    paste0('Bad coordinates: ',
                          coord.listR5l[!check.coordpos.l], ' / ', coord.listR3l[!check.coordpos.l],
                          check.coordpos.t[!check.coordpos.l]))
      )
      
      gene.list <- mapply(fun.subseq.pos.custom, 
                           coord.listR5, coord.listR3, val.sizeampliconR()[[2]], custom = 'deletion', SIMPLIFY = F
                           )
      
      gene.list2 <- do.call(rbind, lapply(gene.list, function(a) a[[1]]))#extract the coord list, withouth the 'stretch'
      
      #I add this 'stretch' as global variable to avoid the pain of passing it between functions
      stretch <<- cbind(gene.list2[,1], do.call(rbind, lapply(gene.list, function(a) a[[2]])))
      reducedmap <- do.call(rbind, lapply(coord.listR5, func.reducedmap)) #note that I'm using the 5' coordinate for guessing genes, ignoring the 3' one.
      gene.list2 <- data.frame("SystematicID"=reducedmap[,1], 
                               "nameID"=gene.list2[,1],
                               reducedmap[,c(3:length(reducedmap))],
                               gene.list2[,2:3],
                               stringsAsFactors = F)
    }
    return(gene.list2)
  })
      
   
overlaps <- reactive({
  #This function takes the overlap regions from the Gibson modules
  #It depends on Gibsonmodules()
  if(Gibsonmodules()[[1]] != 0) {
    val.GibsonOverlapLength()
    module1 <- DNAString(Gibsonmodules()[[1]])
    module2 <- DNAString(Gibsonmodules()[[2]])
    overlaps <- func.Gibsonoverlaps(module1, module2, val.GibsonOverlapLength())
    } else {
      overlaps <- data.frame('region'= c('LF-F', 'LF-R', 'RF-F', 'RF-R'), 'sequence'='', stringsAsFactors = F) 
    }
  cat('Overlaps calculated\n')
  
  return(overlaps)
})

Gibsonmodules <- reactive({
  #This function sets the gibson vector modules and the overlap regions
  #module1 is the backbone, module2 is the insert
  #It depends on:
  #'val.Gibsmodules()
  #'input$GibsonCustom
  #'input$plasmidBackbones
  #'input$Gmodule1,
  #'input$Gmodule2,
  #'vectorData
  
  
  if(input$GibsonCustom == 1) {
    if(input$Gmodule1 != "" | input$Gmodule2 != ""){
      val.Gibsmodules()
      cat('flanking regions (Gibson modules) validated\n')
      return(list(input$Gmodule1, input$Gmodule2))
    } else return(list(0,0))
    
  }
  
  
  if(input$GibsonCustom == 0) {
    
    if(input$plasmidBackbones != 'noInput') {
      #first validate that N-ter and C-ter insertions correspond to N-ter and C-ter plasmids
      ipB <- strsplit(input$plasmidBackbones, '.', fixed=T)[[1]][1]
      if(ipB == 'NTER') {
        validate(need(input$radio %in% c(1,3,4),
                      'You cannot use a N-ter plasmid to do an C-ter insertion'))
      } else validate(need(input$radio %in% c(2,3,4),
                           'You cannot use an C-ter plasmid to do a N-ter insertion'))
      
      
      vd <- vectorData[[3]] #these are the plasmid names and modules, coming from the workspace vectorData.RData
      vd <- vd[vd[,1] ==  input$plasmidBackbones, ]
      cat('flanking regions (Gibson modules) validated\n')
      return(list(vd[,"insert.sequence"], vd[,"backbone.sequence"]))
    } else return(list(0,0))
  }
})

    

  #These functions design the primers
    primersHRch <- reactive({
      
      ##HR primer design and flanking region trimming. Overlaps (if present) are added with func.designprimersParse
      # design the primers for the left flanking region (LF, 5' to the ATG)
      gene.list()
      val.sizeampliconR()
      
      HR_LF.primers <- do.call(rbind, mapply(func.primer_HRLF, 
                                             name = gene.list()$nameID,
                                             sequence = gene.list()$LF,
                                             sizeamplicon = val.sizeampliconR()[[1]],
                                             maxsize = val.sizeampliconR()[[2]],
                                             SIMPLIFY=F))
      validate(need(!is.null(HR_LF.primers), "Sorry, but no HR_LF primers could be designed. Try changing the flanking region size")
      )
      # design the primers for the right flanking region (RF, ATG and 3')
      HR_RF.primers <- do.call(rbind, mapply(func.primer_HRRF,
                                             name = gene.list()$nameID,
                                             sequence = gene.list()$RF,
                                             sizeamplicon = val.sizeampliconR()[[1]],
                                             SIMPLIFY=F))
      validate(need(!is.null(HR_RF.primers), "Sorry, but no HR_RF primers could be designed. Try changing the flanking region size")
      )
      cat("primers to create a PCR product for homologous recombination... designed\n")
      
      primersHRch <- fun.designPrimers(genelist = gene.list(),
                                       maxsize = val.sizeampliconR(),
                                       HRL = HR_LF.primers,
                                       HRR = HR_RF.primers,
                                       cusdeletion = input$radio
                                       )
      validate(need(!is.null(primersHRch[[3]]), "Sorry, but no ch_primers could be designed. Try changing the flanking region size")
      )
      return(primersHRch)
      })

    primers.vector <- reactive({
      Gibsonmodules()
      if(input$GibsonCustom == 1) {
        primers.vector <- func.designprimersVector.C1(seqVector = Gibsonmodules()[1:2],
                                                      vectorData = vectorData)
      } else {
        if(input$plasmidBackbones != 'noInput') {
          primers.vector <- func.designprimersVector.C0(seqVector =Gibsonmodules()[1:2],
                                                        vData.f = input$plasmidBackbones,
                                                        vectorData = vectorData)
        }}
      })
    
    primers <- reactive({
      gene.list() #This is just to validate that a gene ID has been input, to prevent an error when parsing vector primers with non-yet-designed gene primers
      primersR <- func.designprimersParse(HR_LF.primers = primersHRch()[[1]],
                                          HR_RF.primers = primersHRch()[[2]],
                                          ch.primers = primersHRch()[[3]],
                                          chV.primers = primers.vector()[[3]],
                                          backbone.primers = primers.vector()[[1]],
                                          insert.primers = primers.vector()[[2]],
                                          sizeOverlap = val.GibsonOverlapLength(),
                                          genelist = primersHRch()[[4]],
                                          overlapjunctions = overlaps()
                                          )
      cat('HR and ch primers... appended in file\n')
      return(primersR)
    })

upgene.list <- reactive({
  #it depends on:
  #'fun.designPrimers() for the primer-updated flanking regions and gene data
  #'Gibsonmodules() for the vector modules
  
  if(Gibsonmodules()[[1]] != 0) {
    glist <- primersHRch()[[4]]
    glist <- data.frame(glist, 'GibsonAssemblies'= paste0(glist$LF,
                                                          Gibsonmodules()[[1]],
                                                          glist$RF,
                                                          Gibsonmodules()[[2]])
                        )
  } else glist <- primersHRch()[[4]]
  
  return(glist)
})

Gibsoncalcs <- reactive({
  Gibsonmodules()
  pmolHR <- as.numeric(input$pmol.HR)
  validate(need(!is.na(pmolHR), 'pmol flanking regions must be a number'))
  pmolvec <- as.numeric(input$pmol.vector)
  validate(need(!is.na(pmolvec), 'pmol vector must be a number'))
  glist <- primers()[[1]]
  
  glist <- glist[seq(2, nrow(glist), 2), c(1,2,4)]
  glist[,3] <- as.numeric(glist[,3])
  glist.HR <- glist[grep('^HR_', glist$Primer),]
  glist.HR[,2] <- gsub('-R$', '', glist.HR[,2])
  glist.HR <- data.frame(glist.HR,
                         'pmol'= pmolHR,
                         'ng' = pmolHR * 1e-3 * (glist.HR[,3] * 617.96 + 36.04)
              )   #moles dsDNA (mol) = mass of dsDNA (g)/((length of dsDNA (bp) x 617.96 g/mol) + 36.04 g/mol)
  
  
  glist.vector <- glist[grep('insert-|back-', glist$Primer),]
  
  if(nrow(glist.vector) != 0) {
       glist.vector <- data.frame(glist.vector,
                         'pmol'= pmolvec,
                         'ng' = pmolvec * 1e-3 * (glist.vector[,3] * 617.96 + 36.04)
                  )
  }
  
  glist <- rbind(glist.HR, glist.vector)
  colnames(glist)[c(2,3)] <- c('Amplicon', 'Amplicon(bp)')
  return(glist)
})

   ## OUTPUT ##
   output$geneID <- renderTable(upgene.list()[1:6])
   output$geneIDDownload <- downloadHandler(
     filename = 'geneID.txt',
     content = function(file) write.table(upgene.list(), file, sep='\t', quote=F, row.names=F, na='')
   )

   
   output$allPrimers <- renderTable(primers()[[1]], na='', digits=1)
   output$allPrimersDownload <- downloadHandler(
     filename = 'Primers.txt',
     content = function(file) write.table(primers()[[1]], file, sep='\t', quote=F, row.names=F, na='')
   )
    
   output$overlapdata <- renderTable(overlaps())
   output$plasmid <- renderText(input$plasmidBackbones)
   
   output$Gibsoncalcsdata <- renderTable(Gibsoncalcs())
   output$GibsoncalcsDownload <- downloadHandler(
     filename = 'Molarity_calculations.txt',
     content = function(file) write.table(Gibsoncalcs(), file, sep='\t', quote=F, row.names=F, na='')
   )
   
})